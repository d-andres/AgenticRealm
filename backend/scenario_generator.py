"""
Scenario Generator - AI-driven dynamic scenario creation

This module provides the interface for AI models (LLMs, Copilot, AgentGPT, etc.)
to generate unique scenario instances from templates.

When a scenario instance is created via API, this generator:
1. Takes a ScenarioTemplate from scenarios.py
2. Calls an AI model to generate unique:
   - Store names, locations, proprietor personalities
   - NPC characters, jobs, skills, relationships
   - Item inventories and strategic prices
   - The target item and success conditions
   - Environmental storytelling and flavor

Each generation is unique - no two scenario instances are identical.
"""

from typing import Dict, List, Any, Callable, Optional
from dataclasses import dataclass
import random
from scenarios import ScenarioTemplate


@dataclass
class GeneratedStore:
    """A store generated by AI for a scenario instance"""
    store_id: str
    name: str
    location: tuple  # (x, y)
    proprietor_name: str
    proprietor_personality: str  # description of their character
    inventory: Dict[str, Dict[str, Any]]  # item_id -> {name, value, rarity, description}
    pricing_multiplier: float  # how much they markup goods
    store_type: str  # "general", "specialty", "black_market", "rare", etc.


@dataclass
class GeneratedNPC:
    """An NPC generated by AI for a scenario instance"""
    npc_id: str
    name: str
    job: str  # shopkeeper, guard, thief, merchant, information_broker, etc.
    location: tuple  # (x, y)
    personality: str  # description of their demeanor/morality
    skills: Dict[str, int]  # {skill_name: skill_level (1-3)}
    initial_trust: float  # 0-1, how they feel about player initially
    hiring_cost: Optional[int]  # None if not hirable, otherwise gold cost
    relationship_hooks: List[str]  # plot hooks for interaction


@dataclass
class GeneratedScenarioInstance:
    """A complete AI-generated scenario instance ready to play"""
    instance_id: str
    template_id: str
    scenario_name: str
    scenario_description: str
    world_width: int
    world_height: int
    starting_position: tuple
    starting_gold: int
    max_turns: int
    
    # AI-generated content
    stores: List[GeneratedStore]
    npcs: List[GeneratedNPC]
    target_item: Dict[str, Any]  # {store_id, item_id, name, value, description, why_valuable}
    environmental_story: str  # Flavor text about the scenario
    
    # Metadata for understanding the scenario
    multiple_solution_paths: List[str]  # e.g., ["negotiate", "steal", "trade_chain"]
    difficulty_rating: float  # 0-10, how hard is it
    expected_gold_efficiency: tuple  # (min_optimal, max_optimal) gold to spend


class ScenarioGenerator:
    """
    Generates unique scenario instances from templates using an AI decision maker.
    
    The decision_maker is a pluggable AI function:
    - Can be rule-based (deterministic, fast)
    - Can be OpenAI LLM (creative, consistent)
    - Can be Copilot (flexible, multi-modal)
    - Can be AgentGPT (autonomously creative)
    - Can be any callable that returns generation data
    """
    
    def __init__(self, decision_maker: Callable[[str, Dict], Dict]):
        """
        Args:
            decision_maker: Callable that generates scenario content.
                Signature: (generation_type: str, context: dict) -> dict
                
                Example:
                    def ai_decision_maker(gen_type: str, context: dict):
                        if gen_type == "stores":
                            return openai.Completions.create(
                                prompt=f"Generate 5 market stores: {context}"
                            )
                        elif gen_type == "npcs":
                            return copilot_agent.invoke(
                                {"type": "npc_generation", "context": context}
                            )
        """
        self.decision_maker = decision_maker
    
    def generate_instance(
        self,
        template: ScenarioTemplate,
        instance_id: str
    ) -> GeneratedScenarioInstance:
        """
        Generate a unique scenario instance from a template.
        
        Args:
            template: ScenarioTemplate defining rules/constraints
            instance_id: unique identifier for this instance
            
        Returns:
            GeneratedScenarioInstance: complete, fully generated scenario ready to play
        """
        
        # Ask AI to generate stores
        stores = self._generate_stores(template)
        
        # Ask AI to generate NPCs
        npcs = self._generate_npcs(template, stores)
        
        # Ask AI to generate items and populate store inventories
        self._populate_store_inventories(template, stores)
        
        # Ask AI to select and define the target item
        target_item = self._generate_target_item(template, stores)
        
        # Ask AI to generate environmental storytelling
        environmental_story = self._generate_story(template, stores, npcs, target_item)
        
        # Ask AI to identify multiple solution paths
        solution_paths = self._identify_solution_paths(template, stores, npcs, target_item)
        
        # Calculate difficulty and efficiency expectations
        difficulty = self._calculate_difficulty(template, stores, npcs, target_item)
        gold_efficiency = self._calculate_efficiency_range(template, solution_paths)
        
        return GeneratedScenarioInstance(
            instance_id=instance_id,
            template_id=template.scenario_id,
            scenario_name=template.name,
            scenario_description=template.description,
            world_width=template.world_width,
            world_height=template.world_height,
            starting_position=(50, 50),
            starting_gold=template.starting_gold,
            max_turns=template.max_turns,
            stores=stores,
            npcs=npcs,
            target_item=target_item,
            environmental_story=environmental_story,
            multiple_solution_paths=solution_paths,
            difficulty_rating=difficulty,
            expected_gold_efficiency=gold_efficiency,
        )
    
    def _generate_stores(self, template: ScenarioTemplate) -> List[GeneratedStore]:
        """Ask AI to generate stores for this scenario"""
        num_stores = random.randint(*template.num_stores)
        
        context = {
            "num_stores": num_stores,
            "themes": template.environment_themes,
            "world_width": template.world_width,
            "world_height": template.world_height,
            "store_types": ["general", "specialty", "black_market", "rare", "shady"],
        }
        
        # Call the decision maker to generate stores
        result = self.decision_maker("generate_stores", context)
        
        # Parse result into GeneratedStore objects
        return self._parse_generated_stores(result)
    
    def _generate_npcs(
        self,
        template: ScenarioTemplate,
        stores: List[GeneratedStore]
    ) -> List[GeneratedNPC]:
        """Ask AI to generate NPCs for this scenario"""
        num_npcs = random.randint(*template.num_npcs)
        
        context = {
            "num_npcs": num_npcs,
            "possible_jobs": template.possible_npc_jobs,
            "world_width": template.world_width,
            "world_height": template.world_height,
            "stores": [s.name for s in stores],
            "themes": template.environment_themes,
        }
        
        result = self.decision_maker("generate_npcs", context)
        return self._parse_generated_npcs(result)
    
    def _populate_store_inventories(
        self,
        template: ScenarioTemplate,
        stores: List[GeneratedStore]
    ) -> None:
        """Ask AI to populate store inventories with items"""
        num_items = random.randint(*template.num_items)
        
        context = {
            "num_items": num_items,
            "rarity_distribution": template.item_rarity_distribution,
            "num_stores": len(stores),
            "store_names": [s.name for s in stores],
            "themes": template.environment_themes,
        }
        
        result = self.decision_maker("generate_items_and_inventory", context)
        
        # Parse and assign items to stores
        self._assign_items_to_stores(stores, result)
    
    def _generate_target_item(
        self,
        template: ScenarioTemplate,
        stores: List[GeneratedStore]
    ) -> Dict[str, Any]:
        """Ask AI to select and define the target item"""
        context = {
            "objective": template.objectives[0] if template.objectives else "acquire item",
            "starting_gold": template.starting_gold,
            "store_names": [s.name for s in stores],
            "themes": template.environment_themes,
        }
        
        result = self.decision_maker("generate_target_item", context)
        return result
    
    def _generate_story(
        self,
        template: ScenarioTemplate,
        stores: List[GeneratedStore],
        npcs: List[GeneratedNPC],
        target_item: Dict[str, Any]
    ) -> str:
        """Ask AI to generate environmental storytelling"""
        context = {
            "themes": template.environment_themes,
            "store_count": len(stores),
            "npc_count": len(npcs),
            "target_item_name": target_item.get("name"),
            "tone": "immersive",
        }
        
        result = self.decision_maker("generate_story", context)
        return result.get("story", "A mysterious market awaits...")
    
    def _identify_solution_paths(
        self,
        template: ScenarioTemplate,
        stores: List[GeneratedStore],
        npcs: List[GeneratedNPC],
        target_item: Dict[str, Any]
    ) -> List[str]:
        """Ask AI to identify multiple solution paths for this scenario"""
        context = {
            "target_item": target_item,
            "available_actions": [a.value for a in template.allowed_actions],
            "num_stores": len(stores),
            "num_npcs": len(npcs),
            "starting_gold": template.starting_gold,
        }
        
        result = self.decision_maker("identify_solution_paths", context)
        return result.get("paths", ["negotiate", "steal", "trade"])
    
    def _calculate_difficulty(
        self,
        template: ScenarioTemplate,
        stores: List[GeneratedStore],
        npcs: List[GeneratedNPC],
        target_item: Dict[str, Any]
    ) -> float:
        """Ask AI to assess scenario difficulty"""
        context = {
            "template_difficulty": template.difficulty,
            "target_price": target_item.get("price"),
            "starting_gold": template.starting_gold,
            "guard_count": len([n for n in npcs if n.job == "guard"]),
            "thief_availability": any(n.job == "thief" for n in npcs),
        }
        
        result = self.decision_maker("calculate_difficulty", context)
        return result.get("difficulty", 5.0)
    
    def _calculate_efficiency_range(
        self,
        template: ScenarioTemplate,
        solution_paths: List[str]
    ) -> tuple:
        """Calculate expected optimal gold spending range"""
        # Estimate based on solution paths
        min_gold = max(100, template.starting_gold // 3)  # Efficient path
        max_gold = min(template.starting_gold, template.starting_gold)  # All your gold
        return (min_gold, max_gold)
    
    # Helper parsing methods (implement based on your AI response format)
    def _parse_generated_stores(self, result: Dict) -> List[GeneratedStore]:
        """Parse AI-generated store data into GeneratedStore objects"""
        # This depends on your AI decision maker output format
        # Stub for now - implement based on actual AI provider
        return []
    
    def _parse_generated_npcs(self, result: Dict) -> List[GeneratedNPC]:
        """Parse AI-generated NPC data into GeneratedNPC objects"""
        # Stub for now
        return []
    
    def _assign_items_to_stores(
        self,
        stores: List[GeneratedStore],
        inventory_data: Dict
    ) -> None:
        """Assign generated items to store inventories"""
        # Stub for now
        pass


def create_scenario_instance_from_template(
    template_id: str,
    instance_id: str,
    decision_maker: Callable[[str, Dict], Dict]
) -> GeneratedScenarioInstance:
    """
    Convenience function to generate a scenario instance.
    
    Args:
        template_id: ID of scenario template to use
        instance_id: Unique ID for this instance
        decision_maker: AI/logic function for generation
        
    Returns:
        GeneratedScenarioInstance: Complete scenario ready to play
    """
    from scenarios import ScenarioManager
    
    template = ScenarioManager.get_template(template_id)
    if not template:
        raise ValueError(f"Unknown scenario template: {template_id}")
    
    generator = ScenarioGenerator(decision_maker)
    return generator.generate_instance(template, instance_id)
