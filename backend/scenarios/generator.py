"""
Scenario Generator - AI-driven dynamic scenario creation

This module provides the interface for AI models (LLMs, Copilot, AgentGPT, etc.)
to generate unique scenario instances from templates.

When a scenario instance is created via API, this generator:
1. Takes a ScenarioTemplate from templates.py
2. Calls an AI model to generate unique:
   - Store names, locations, proprietor personalities
   - NPC characters, jobs, skills, relationships
   - Item inventories and strategic prices
   - The target item and success conditions
   - Environmental storytelling and flavor

Each generation is unique - no two scenario instances are identical.
"""

from typing import Dict, List, Any, Callable, Optional, Tuple
from dataclasses import dataclass
import math
import random
from scenarios.templates import ScenarioTemplate


@dataclass
class GeneratedStore:
    """A store generated by AI for a scenario instance"""
    store_id: str
    name: str
    location: tuple  # (x, y)
    proprietor_name: str
    proprietor_personality: str  # description of their character
    inventory: Dict[str, Dict[str, Any]]  # item_id -> {name, value, rarity, description}
    pricing_multiplier: float  # how much they markup goods
    store_type: str  # "general", "specialty", "black_market", "rare", etc.


@dataclass
class GeneratedNPC:
    """An NPC generated by AI for a scenario instance"""
    npc_id: str
    name: str
    job: str  # shopkeeper, guard, thief, merchant, information_broker, etc.
    location: tuple  # (x, y)
    personality: str  # description of their demeanor/morality
    skills: Dict[str, int]  # {skill_name: skill_level (1-3)}
    initial_trust: float  # 0-1, how they feel about player initially
    hiring_cost: Optional[int]  # None if not hirable, otherwise gold cost
    relationship_hooks: List[str]  # plot hooks for interaction


@dataclass
class GeneratedScenarioInstance:
    """A complete AI-generated scenario instance ready to play"""
    instance_id: str
    template_id: str
    scenario_name: str
    scenario_description: str
    world_width: int
    world_height: int
    starting_position: tuple
    starting_gold: int
    max_turns: int
    
    # AI-generated content
    stores: List[GeneratedStore]
    npcs: List[GeneratedNPC]
    target_item: Dict[str, Any]  # {store_id, item_id, name, value, description, why_valuable}
    environmental_story: str  # Flavor text about the scenario
    
    # Metadata for understanding the scenario
    multiple_solution_paths: List[str]  # e.g., ["negotiate", "steal", "trade_chain"]
    difficulty_rating: float  # 0-10, how hard is it
    expected_gold_efficiency: tuple  # (min_optimal, max_optimal) gold to spend


class ScenarioGenerator:
    """
    Generates unique scenario instances from templates using an AI decision maker.
    
    The decision_maker is a pluggable AI function:
    - Can be rule-based (deterministic, fast)
    - Can be OpenAI LLM (creative, consistent)
    - Can be Anthropic Claude (flexible, multi-modal)
    - Can be any callable that returns generation data
    """
    
    def __init__(self, decision_maker: Callable[[str, Dict], Dict]):
        """
        Args:
            decision_maker: Callable that generates scenario content.
                Signature: (generation_type: str, context: dict) -> dict
        """
        self.decision_maker = decision_maker
    
    def generate_instance(
        self,
        template: ScenarioTemplate,
        instance_id: str
    ) -> GeneratedScenarioInstance:
        """
        Generate a unique scenario instance from a template.
        
        Args:
            template: ScenarioTemplate defining rules/constraints
            instance_id: unique identifier for this instance
            
        Returns:
            GeneratedScenarioInstance: complete, fully generated scenario ready to play
        """
        stores = self._generate_stores(template)
        npcs = self._generate_npcs(template, stores)
        self._populate_store_inventories(template, stores)
        target_item = self._generate_target_item(template, stores)
        environmental_story = self._generate_story(template, stores, npcs, target_item)
        solution_paths = self._identify_solution_paths(template, stores, npcs, target_item)
        difficulty = self._calculate_difficulty(template, stores, npcs, target_item)
        gold_efficiency = self._calculate_efficiency_range(template, solution_paths)
        
        return GeneratedScenarioInstance(
            instance_id=instance_id,
            template_id=template.scenario_id,
            scenario_name=template.name,
            scenario_description=template.description,
            world_width=template.world_width,
            world_height=template.world_height,
            starting_position=(50, 50),
            starting_gold=template.starting_gold,
            max_turns=template.max_turns,
            stores=stores,
            npcs=npcs,
            target_item=target_item,
            environmental_story=environmental_story,
            multiple_solution_paths=solution_paths,
            difficulty_rating=difficulty,
            expected_gold_efficiency=gold_efficiency,
        )
    
    def _generate_stores(self, template: ScenarioTemplate) -> List[GeneratedStore]:
        """Ask AI to generate stores for this scenario"""
        num_stores = random.randint(*template.num_stores)
        context = {
            "num_stores": num_stores,
            "themes": template.environment_themes,
            "world_width": template.world_width,
            "world_height": template.world_height,
            "store_types": ["general", "specialty", "black_market", "rare", "shady"],
        }
        result = self.decision_maker("generate_stores", context)
        return self._parse_generated_stores(result)
    
    def _generate_npcs(self, template: ScenarioTemplate, stores: List[GeneratedStore]) -> List[GeneratedNPC]:
        """Ask AI to generate NPCs for this scenario"""
        num_npcs = random.randint(*template.num_npcs)
        context = {
            "num_npcs": num_npcs,
            "possible_jobs": template.possible_npc_jobs,
            "world_width": template.world_width,
            "world_height": template.world_height,
            "stores": [s.name for s in stores],
            "themes": template.environment_themes,
        }
        result = self.decision_maker("generate_npcs", context)
        return self._parse_generated_npcs(result)
    
    def _populate_store_inventories(self, template: ScenarioTemplate, stores: List[GeneratedStore]) -> None:
        """Ask AI to populate store inventories with items"""
        num_items = random.randint(*template.num_items)
        context = {
            "num_items": num_items,
            "rarity_distribution": template.item_rarity_distribution,
            "num_stores": len(stores),
            "store_names": [s.name for s in stores],
            "themes": template.environment_themes,
        }
        result = self.decision_maker("generate_items_and_inventory", context)
        self._assign_items_to_stores(stores, result)
    
    def _generate_target_item(self, template: ScenarioTemplate, stores: List[GeneratedStore]) -> Dict[str, Any]:
        """Ask AI to select and define the target item"""
        context = {
            "objective": template.objectives[0] if template.objectives else "acquire item",
            "starting_gold": template.starting_gold,
            "store_names": [s.name for s in stores],
            "themes": template.environment_themes,
        }
        return self.decision_maker("generate_target_item", context)
    
    def _generate_story(
        self,
        template: ScenarioTemplate,
        stores: List[GeneratedStore],
        npcs: List[GeneratedNPC],
        target_item: Dict[str, Any]
    ) -> str:
        """Ask AI to generate environmental storytelling"""
        context = {
            "themes": template.environment_themes,
            "store_count": len(stores),
            "npc_count": len(npcs),
            "target_item_name": target_item.get("name"),
            "tone": "immersive",
        }
        result = self.decision_maker("generate_story", context)
        return result.get("story", "A mysterious market awaits...")
    
    def _identify_solution_paths(
        self,
        template: ScenarioTemplate,
        stores: List[GeneratedStore],
        npcs: List[GeneratedNPC],
        target_item: Dict[str, Any]
    ) -> List[str]:
        """Ask AI to identify multiple solution paths for this scenario"""
        context = {
            "target_item": target_item,
            "available_actions": [a.value for a in template.allowed_actions],
            "num_stores": len(stores),
            "num_npcs": len(npcs),
            "starting_gold": template.starting_gold,
        }
        result = self.decision_maker("identify_solution_paths", context)
        return result.get("paths", ["negotiate", "steal", "trade"])
    
    def _calculate_difficulty(
        self,
        template: ScenarioTemplate,
        stores: List[GeneratedStore],
        npcs: List[GeneratedNPC],
        target_item: Dict[str, Any]
    ) -> float:
        """Ask AI to assess scenario difficulty"""
        context = {
            "template_difficulty": template.difficulty,
            "target_price": target_item.get("price"),
            "starting_gold": template.starting_gold,
            "guard_count": len([n for n in npcs if n.job == "guard"]),
            "thief_availability": any(n.job == "thief" for n in npcs),
        }
        result = self.decision_maker("calculate_difficulty", context)
        return result.get("difficulty", 5.0)
    
    def _calculate_efficiency_range(self, template: ScenarioTemplate, solution_paths: List[str]) -> tuple:
        """Calculate expected optimal gold spending range"""
        min_gold = max(100, template.starting_gold // 3)
        max_gold = template.starting_gold
        return (min_gold, max_gold)
    
    # ---- Stub parsers: implement once AI provider response format is defined ----

    def _parse_generated_stores(self, result: Dict) -> List[GeneratedStore]:
        """Parse AI- or rule-generated store data into GeneratedStore objects."""
        stores = []
        for s in result.get("stores", []):
            stores.append(GeneratedStore(
                store_id=s.get("store_id", f"store_{len(stores)+1}"),
                name=s.get("name", "Unknown Store"),
                location=(float(s.get("x", 0)), float(s.get("y", 0))),
                proprietor_name=s.get("proprietor", "Unknown"),
                proprietor_personality=s.get("proprietor_personality", "neutral"),
                inventory=s.get("inventory", {}),
                pricing_multiplier=float(s.get("pricing_multiplier", 1.0)),
                store_type=s.get("store_type", "general"),
            ))
        return stores

    def _parse_generated_npcs(self, result: Dict) -> List[GeneratedNPC]:
        """Parse AI- or rule-generated NPC data into GeneratedNPC objects."""
        npcs = []
        for n in result.get("npcs", []):
            npcs.append(GeneratedNPC(
                npc_id=n.get("npc_id", f"npc_{len(npcs)+1}"),
                name=n.get("name", "Unknown"),
                job=n.get("job", "unknown"),
                location=(float(n.get("x", 0)), float(n.get("y", 0))),
                personality=n.get("personality", "neutral"),
                skills=n.get("skills", {}),
                initial_trust=float(n.get("initial_trust", 0.5)),
                hiring_cost=n.get("hiring_cost"),
                relationship_hooks=[],
            ))
        return npcs

    def _assign_items_to_stores(self, stores: List[GeneratedStore], inventory_data: Dict) -> None:
        """Assign generated items to store inventories."""
        items = inventory_data.get("items", [])
        assignments = inventory_data.get("assignments", {})
        item_map = {item["item_id"]: item for item in items}
        assigned_ids: set = set()

        for store in stores:
            for iid in assignments.get(store.store_id, []):
                if iid in item_map:
                    store.inventory[iid] = item_map[iid]
                    assigned_ids.add(iid)

        # Distribute unassigned items round-robin
        unassigned = [item for item in items if item["item_id"] not in assigned_ids]
        for j, item in enumerate(unassigned):
            if stores:
                stores[j % len(stores)].inventory[item["item_id"]] = item


def create_scenario_instance_from_template(
    template_id: str,
    instance_id: str,
    decision_maker: Callable[[str, Dict], Dict]
) -> GeneratedScenarioInstance:
    """
    Convenience function to generate a scenario instance.

    Args:
        template_id: ID of scenario template to use
        instance_id: Unique ID for this instance
        decision_maker: AI/logic function for generation

    Returns:
        GeneratedScenarioInstance: Complete scenario ready to play
    """
    from scenarios.templates import ScenarioManager

    template = ScenarioManager.get_template(template_id)
    if not template:
        raise ValueError(f"Unknown scenario template: {template_id}")

    generator = ScenarioGenerator(decision_maker)
    return generator.generate_instance(template, instance_id)


# ---------------------------------------------------------------------------
# Rule-based decision maker (no LLM required)
# ---------------------------------------------------------------------------

_STORE_NAME_PARTS = [
    ["The Golden", "The Silver", "The Iron", "The Rusty", "The Hidden", "The Open"],
    ["Barrel", "Anvil", "Lantern", "Scales", "Vault", "Stall", "Bazaar"],
]
_PROPRIETOR_FIRST = ["Gareth", "Mira", "Orin", "Sera", "Tomas", "Lyra", "Edric", "Nessa"]
_PROPRIETOR_LAST  = ["Dusk", "Coin", "Flint", "Vale", "Shaw", "Cross", "Pike", "Marsh"]
_PERSONALITIES    = [
    "friendly and chatty",
    "suspicious but fair",
    "gruff and impatient",
    "sly and calculating",
    "honest and straightforward",
    "secretive and cautious",
]
_NPC_FIRST = ["Brin", "Cael", "Dova", "Fenn", "Hara", "Jorin", "Kell", "Lena"]
_NPC_LAST  = ["Stone", "Reed", "Ash", "Moon", "Tide", "Wind", "Scar", "Bolt"]

_ITEM_POOL = [
    {"item_id": "ruby_gem",      "name": "Ruby Gem",            "value": 800,  "rarity": "rare",     "description": "A deep crimson gemstone",          "tradeable": True},
    {"item_id": "silver_dagger", "name": "Silver Dagger",        "value": 300,  "rarity": "uncommon", "description": "Finely crafted short blade",        "tradeable": True},
    {"item_id": "healing_potion","name": "Healing Potion",       "value": 80,   "rarity": "common",   "description": "Restores vitality",                 "tradeable": True},
    {"item_id": "silk_cloth",    "name": "Bolt of Silk Cloth",   "value": 120,  "rarity": "common",   "description": "Smooth and lustrous fabric",        "tradeable": True},
    {"item_id": "old_map",       "name": "Old Maps Bundle",      "value": 200,  "rarity": "uncommon", "description": "Charts of unknown territories",     "tradeable": True},
    {"item_id": "ancient_coin",  "name": "Ancient Coin",         "value": 450,  "rarity": "rare",     "description": "Minted in a forgotten empire",      "tradeable": True},
    {"item_id": "iron_key",      "name": "Iron Key",             "value": 50,   "rarity": "common",   "description": "Unlocks something important",       "tradeable": True},
    {"item_id": "spell_scroll",  "name": "Spell Scroll",         "value": 600,  "rarity": "rare",     "description": "Arcane text of unknown power",       "tradeable": True},
    {"item_id": "spice_bundle",  "name": "Exotic Spice Bundle",  "value": 90,   "rarity": "common",   "description": "Rare spices from distant lands",     "tradeable": True},
    {"item_id": "bronze_statue", "name": "Bronze Statuette",     "value": 350,  "rarity": "uncommon", "description": "A small but intricately cast figure", "tradeable": True},
    {"item_id": "poison_vial",   "name": "Vial of Dark Tincture","value": 250,  "rarity": "uncommon", "description": "Unclear purpose; handle carefully",  "tradeable": False},
    {"item_id": "lockpick_set",  "name": "Lockpick Set",         "value": 150,  "rarity": "common",   "description": "Professional-grade tools",           "tradeable": True},
    {"item_id": "jade_figurine", "name": "Jade Figurine",        "value": 900,  "rarity": "legendary","description": "Exquisite miniature jade carving",    "tradeable": True},
    {"item_id": "torn_letter",   "name": "Torn Letter",          "value": 30,   "rarity": "common",   "description": "Partial correspondence; intriguing", "tradeable": True},
    {"item_id": "copper_ingot",  "name": "Copper Ingot",         "value": 60,   "rarity": "common",   "description": "Raw material; useful to smiths",     "tradeable": True},
]


def _rule_based_decision_maker(generation_type: str, context: Dict) -> Dict:
    """
    Deterministic rule-based decision maker for scenario generation.

    Does NOT require any LLM or API key.  All output is seeded from
    ``random`` so results vary between instances but never block on I/O.
    Used as the fallback when no ``scenario_generator`` AI agent is connected.
    """
    rng = random.Random()  # unseeded → different each call

    if generation_type == "generate_stores":
        num = context.get("num_stores", 4)
        world_w = context.get("world_width", 800)
        world_h = context.get("world_height", 600)
        stores = []
        for i in range(num):
            stype = rng.choice(["general", "specialty", "black_market", "rare", "shady"])
            x = rng.uniform(50, world_w - 50)
            y = rng.uniform(50, world_h - 50)
            name = rng.choice(_STORE_NAME_PARTS[0]) + " " + rng.choice(_STORE_NAME_PARTS[1])
            stores.append({
                "store_id": f"store_{i+1}",
                "name": name,
                "proprietor": rng.choice(_PROPRIETOR_FIRST) + " " + rng.choice(_PROPRIETOR_LAST),
                "proprietor_personality": rng.choice(_PERSONALITIES),
                "store_type": stype,
                "pricing_multiplier": round(rng.uniform(0.8, 2.5), 2),
                "x": round(x),
                "y": round(y),
                "inventory": {},
            })
        return {"stores": stores}

    if generation_type == "generate_npcs":
        num = context.get("num_npcs", 5)
        possible_jobs = context.get("possible_jobs", ["shopkeeper", "guard", "thief", "merchant"])
        world_w = context.get("world_width", 800)
        world_h = context.get("world_height", 600)
        npcs = []
        # Guarantee at least one guard so steal probability isn't trivially 70 %
        jobs = ["guard"] + [rng.choice(possible_jobs) for _ in range(max(0, num - 1))]
        rng.shuffle(jobs)
        for i, job in enumerate(jobs):
            hiring_cost = None
            if job in ("thief", "merchant", "information_broker", "fence"):
                hiring_cost = rng.randint(50, 300)
            npcs.append({
                "npc_id": f"npc_{i+1}",
                "name": rng.choice(_NPC_FIRST) + " " + rng.choice(_NPC_LAST),
                "job": job,
                "personality": rng.choice(_PERSONALITIES),
                "skills": {job: rng.randint(1, 3)},
                "initial_trust": round(rng.uniform(0.2, 0.9), 2),
                "hiring_cost": hiring_cost,
                "x": round(rng.uniform(30, world_w - 30)),
                "y": round(rng.uniform(30, world_h - 30)),
            })
        return {"npcs": npcs}

    if generation_type == "generate_items_and_inventory":
        num_items = context.get("num_items", 10)
        items = rng.sample(_ITEM_POOL, min(num_items, len(_ITEM_POOL)))
        return {"items": items, "assignments": {}}

    if generation_type == "generate_target_item":
        target = rng.choice([i for i in _ITEM_POOL if i["rarity"] in ("rare", "legendary")])
        return {
            "item_id": target["item_id"],
            "name": target["name"],
            "base_value": target["value"] * 2,
            "why_valuable": "Rumoured to be sought by several powerful factions.",
            "location": "store_1",
            "proprietor_reaction": "Hesitant — asks why you want it.",
        }

    if generation_type == "generate_story":
        return {"story": "The market hums with activity.  Opportunity and danger lurk in equal measure."}

    if generation_type in ("identify_solution_paths", "calculate_difficulty"):
        return {}

    return {}


# ---------------------------------------------------------------------------
# Main entry point used by the route layer
# ---------------------------------------------------------------------------

async def generate_world_entities(
    instance,
    agent_pool=None,
) -> None:
    """Generate all world entities for a ``ScenarioInstance`` and apply them.

    Priority order for the decision maker:
    1. A connected ``scenario_generator`` AI agent from *agent_pool* (LLM-backed).
    2. The built-in ``_rule_based_decision_maker`` (instant, no API key needed).

    The function:
    - Marks the instance as ``"generating"``.
    - Builds stores, NPCs, and items via the chosen decision maker.
    - Converts results to :class:`core.state.Entity` objects.
    - Calls ``instance.apply_entities(...)`` which marks the instance ``"active"``.

    This is designed to be run as a fire-and-forget background task so that
    the HTTP response is returned immediately while generation happens in the
    background.
    """
    from core.state import Entity
    from ai_agents.interfaces import AgentRole

    instance.status = "generating"
    template = instance.scenario
    if template is None:
        instance.status = "error"
        return

    # --- Choose decision maker -------------------------------------------
    def _sync_decision_maker(gen_type: str, ctx: Dict) -> Dict:
        return _rule_based_decision_maker(gen_type, ctx)

    async def _ai_decision_maker(gen_type: str, ctx: Dict) -> Dict:
        resp = await agent_pool.request(
            role=AgentRole.SCENARIO_GENERATOR,
            action=gen_type,
            context=ctx,
        )
        if resp and resp.success and resp.result and "error" not in resp.result:
            return resp.result
        # Fall back to rule-based if AI returns nothing useful
        return _rule_based_decision_maker(gen_type, ctx)

    use_ai = (
        agent_pool is not None
        and AgentRole.SCENARIO_GENERATOR in agent_pool.agents
        and len(agent_pool.agents[AgentRole.SCENARIO_GENERATOR]) > 0
    )

    async def call(gen_type: str, ctx: Dict) -> Dict:
        if use_ai:
            return await _ai_decision_maker(gen_type, ctx)
        return _sync_decision_maker(gen_type, ctx)

    try:
        # 1. Generate stores
        num_stores = random.randint(*template.num_stores)
        store_data = await call("generate_stores", {
            "num_stores": num_stores,
            "themes": template.environment_themes,
            "world_width": template.world_width,
            "world_height": template.world_height,
        })
        gen = ScenarioGenerator(_sync_decision_maker)
        stores = gen._parse_generated_stores(store_data)

        # 2. Generate NPCs
        num_npcs = random.randint(*template.num_npcs)
        npc_data = await call("generate_npcs", {
            "num_npcs": num_npcs,
            "possible_jobs": template.possible_npc_jobs,
            "world_width": template.world_width,
            "world_height": template.world_height,
            "stores": [s.name for s in stores],
            "themes": template.environment_themes,
        })
        npcs = gen._parse_generated_npcs(npc_data)

        # 3. Generate items and assign to stores
        num_items = random.randint(*template.num_items)
        item_data = await call("generate_items_and_inventory", {
            "num_items": num_items,
            "rarity_distribution": template.item_rarity_distribution,
            "num_stores": len(stores),
            "store_names": [s.name for s in stores],
            "themes": template.environment_themes,
        })
        gen._assign_items_to_stores(stores, item_data)

        # 4. Determine target item (place it in the first store if not already there)
        target_data = await call("generate_target_item", {
            "objective": template.objectives[0] if template.objectives else "acquire item",
            "starting_gold": template.starting_gold,
            "store_names": [s.name for s in stores],
            "themes": template.environment_themes,
        })
        target_item_id: Optional[str] = target_data.get("item_id")
        if target_item_id and stores:
            # Ensure the target item is in at least one store
            already_present = any(target_item_id in s.inventory for s in stores)
            if not already_present:
                from scenarios.generator import _ITEM_POOL as pool
                item_def = next((it for it in pool if it["item_id"] == target_item_id), None)
                if item_def:
                    stores[0].inventory[target_item_id] = item_def

        # 5. Convert to Entity objects and apply
        entities = []

        for store in stores:
            entities.append(Entity(
                id=store.store_id,
                type="store",
                x=store.location[0],
                y=store.location[1],
                properties={
                    "name": store.name,
                    "proprietor": store.proprietor_name,
                    "proprietor_personality": store.proprietor_personality,
                    "store_type": store.store_type,
                    "pricing_multiplier": store.pricing_multiplier,
                    "inventory": store.inventory,
                    "default_response": f"{store.proprietor_name} looks up and nods.",
                },
            ))

        for npc in npcs:
            entities.append(Entity(
                id=npc.npc_id,
                type="npc",
                x=npc.location[0],
                y=npc.location[1],
                properties={
                    "name": npc.name,
                    "job": npc.job,
                    "personality": npc.personality,
                    "skills": npc.skills,
                    "trust": npc.initial_trust,
                    "hiring_cost": npc.hiring_cost,
                    "default_response": f"{npc.name} ({npc.job}) regards you with a {npc.personality} expression.",
                },
            ))

        instance.apply_entities(entities, target_item_id=target_item_id)
        print(f"[Generator] Instance {instance.instance_id} ready: "
              f"{len(stores)} stores, {len(npcs)} NPCs, target={target_item_id}")

    except Exception as e:
        print(f"[Generator] Generation failed for {instance.instance_id}: {e}")
        instance.status = "error"
